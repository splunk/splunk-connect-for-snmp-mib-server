-- Copyright 1995 by 3Com Corporation.  All rights reserved.
-- MIB file name:  lbhub-rblc.mib
-- available in these 3Com devices:  FMS, FMS II, and 10BT/BTi hubs
-- For support or more info, check 3Com's web page at http://www.3com.com

LBHUB-RBLC-MIB DEFINITIONS ::= BEGIN

-- Title:	LinkBuilder 1209 MIB
-- Date:	Version 2.0, 8 Dec 1992

IMPORTS
enterprises, OBJECT-TYPE, TimeTicks, IpAddress,
	Counter, Gauge
	    FROM RFC1155-SMI
	DisplayString FROM SNMPv2-TC;


-- This file included so that products can include MIB groups in their
-- own MIB

--  MIB-II (same prefix as MIB-I)

mib-2      OBJECT IDENTIFIER ::= { mgmt 1 }

-- textual conventions

-- DisplayString ::=
--    OCTET STRING
-- This data type is used to model textual information taken
-- from the NVT ASCII character set.  By convention, objects
-- with this syntax are declared as having
--
--      SIZE (0..255)

-- PhysAddress ::=
--    OCTET STRING
-- This data type is used to model media addresses.  For many
-- types of media, this will be in a binary representation.
-- For example, an ethernet address would be represented as
-- a string of 6 octets.


-- groups in MIB-II

system       OBJECT IDENTIFIER ::= { mib-2 1 }

interfaces   OBJECT IDENTIFIER ::= { mib-2 2 }

at           OBJECT IDENTIFIER ::= { mib-2 3 }

ip           OBJECT IDENTIFIER ::= { mib-2 4 }

icmp         OBJECT IDENTIFIER ::= { mib-2 5 }

tcp          OBJECT IDENTIFIER ::= { mib-2 6 }

udp          OBJECT IDENTIFIER ::= { mib-2 7 }

-- This is the 3Com-ised version of the SpiderMIB:
-- The spider Group
--
--   The Spider enterprise node is split into several functional groups.
--   These are intended to be common to all Spider products, giving one
--   MIB for every product, and composite MIBs for groups of products.

bicctech	OBJECT IDENTIFIER ::= { enterprises 170 }
bdn		OBJECT IDENTIFIER ::= { bicctech 1 }
bdnII		OBJECT IDENTIFIER ::= { bdn 1 }
spiderII	OBJECT IDENTIFIER ::= { bdnII 3 }

-- spProduct:
--
--   This contains the Spider product-specific MIB groups.  A separate
--   group exists for each main class of Spider product (bridge, tserver,
--   router, probe, software), in which a product subtree is populated with
--   data common to more than one device of that class (all SpiderBridges,
--   for example).  In addition, the product trees contain a subtree for
--   EACH device, allowing the user to associate data with one particular
--   bridge, for example.

spProduct	OBJECT IDENTIFIER ::=	{ spiderII 1 }

-- spIndex:
--
--   This is used by Spider products to indicate to the management station
--   those groups that are supported in products such as multi-protocol
--   terminal servers or multi-interface routers, and between revisions of
--   products.
--
--   Note that as of SpiderMIB-II (June 1992), the 'spIndex' group is
--   deprecated (we will use the forthcoming agent capability MIB data).

spIndex		OBJECT IDENTIFIER ::=	{ spiderII 2 }

-- spGeneral:
--
--   All Spider products, whatever their type, share a variety of data,
--   held in the general group.  On a per-variable level the products
--   implement parts of the subtrees of this group, according to their
--   capabilities non-booting devices don't support the 'restart' group,
--   for example.)

spGeneral	OBJECT IDENTIFIER ::=	{ spiderII 3 }

-- spSnmp:
--
--   For historical reasons (our MIB appeared long before any working
--   groups were set up to consider trap handling, for example) we have a
--   set of extensions to the basic SNMP administration variables,
--   controlling trap enabling, destinations, community authentication and
--   management station validation.  This group, more than any other, will
--   be deprecated as MIB data sets appear which handle higher level SNMP
--   admin requirements.

spSnmp		OBJECT IDENTIFIER ::=	{ spiderII 4 }

-- spProtocols:
--
--   We include here any protocol data that is (in fact or potentially)
--   common to many Spider products; this can include protocol groups that
--   are being worked on by standards bodies, but which are far from
--   becoming accepted RFCs (the spExperimental' group is intended for
--   those groups that are firm, but as yet have no final resting place in
--   the Internet MIB.)

spProtocols	OBJECT IDENTIFIER ::=	{ spiderII 6 }

-- The bridge Group

bridge		OBJECT IDENTIFIER ::=	{ spProduct 1 }

bridgeID	OBJECT IDENTIFIER ::=	{ bridge 1 }

bridgeData	OBJECT IDENTIFIER ::=	{ bridge 2 }

r285		OBJECT IDENTIFIER ::=	{ bridgeID 3 }

-- The r285 product specific MIB

r285FilterDbase	OBJECT IDENTIFIER ::=	{ r285 1 }

-- The filter database group used by Remote Bridge Line Cards

broadcastFltr OBJECT-TYPE
	SYNTAX	INTEGER {
		off(1),
		on(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The state of broadcast filtering. If this object is
		set to ON then the bridge will not forward frames with
		the ethernet broadcast address. The bridge itself
		will still be able to receive frames with the ethernet
		broadcast address, e.g. ARP requests."
	::=	{ r285FilterDbase 1 }

accessGroupChecking OBJECT-TYPE
	SYNTAX	INTEGER {
		off(1),
		on(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The state of Access Group Checking. If this object is
		ON, then each frame is subject to Access Group
		Checking."
	::=	{ r285FilterDbase 2 }

accessGroupLearning OBJECT-TYPE
	SYNTAX	INTEGER {
		non(1),
		free(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"This object determines whether learned addresses
		belong to the Non Access Group or the Free Access
		Group. It is only valid when accessGroupChecking is
		set to ON."
	::=	{ r285FilterDbase 3 }

accessGroupDbase	OBJECT IDENTIFIER ::=	{ r285FilterDbase 4 }

pcolFltr		OBJECT IDENTIFIER ::=	{ r285FilterDbase 6 }

-- The Access Group Filter filtering database.

accessGroupTableMaxEntries OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The maximum number of entries in the table
		accessGroupTable. In the RBLC this value is 2500."
	::=	{ accessGroupDbase 1 }

accessGroupTableCurEntries OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The current number of entries in the table
		accessGroupTable."
	::=	{ accessGroupDbase 2 }

accessGroupTable OBJECT-TYPE
	SYNTAX	SEQUENCE OF AccessGroupEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"A list of Access Group Entries. The number is given by
		accessGroupTableCurEntries."
	::=	{ accessGroupDbase 3 }

accessGroupEntry OBJECT-TYPE
	SYNTAX	AccessGroupEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"An Access Group Entry."
	INDEX	{ accessGroupAddr }
	::=	{ accessGroupTable 1 }

AccessGroupEntry ::= SEQUENCE {
	accessGroupAddr
		OCTET STRING (SIZE(6)),
	accessGroupInUse
		INTEGER,
	accessGroupNon
		INTEGER,
	accessGroupFree
		INTEGER,
	accessGroupMgmt
		INTEGER,
	accessGroupN1
		INTEGER,
	accessGroupN2
		INTEGER,
	accessGroupN3
		INTEGER,
	accessGroupN4
		INTEGER,
	accessGroupN5
		INTEGER,
	accessGroupN6
		INTEGER,
	accessGroupN7
		INTEGER,
	accessGroupN8
		INTEGER,
	accessGroupN9
		INTEGER,
	accessGroupN10
		INTEGER,
	accessGroupN11
		INTEGER,
	accessGroupN12
		INTEGER,
	accessGroupN13
		INTEGER,
	accessGroupN14
		INTEGER,
	accessGroupN15
		INTEGER,
	accessGroupN16
		INTEGER,
	accessGroupMembers
		INTEGER
}


accessGroupAddr OBJECT-TYPE
	SYNTAX	OCTET STRING
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The MAC address of this entry."
	::=	{ accessGroupEntry 1 }

accessGroupInUse OBJECT-TYPE
	SYNTAX	INTEGER {
		notInUse(1),
		inUse(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"This object is ON for valid entries. The entry may be
		removed by setting this object to OFF."
	::=	{ accessGroupEntry 2 }

accessGroupNon OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to the
		Non-Access group.Membership of this group is
		mutually exclusive from all other groups."
	::=	{ accessGroupEntry 3 }

accessGroupFree OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to the
		Free Access Group."
	::=	{ accessGroupEntry 4 }

accessGroupMgmt OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to the
		Management group.Membership of this group is
		mutually exclusive from all other groups."
	::=	{ accessGroupEntry 5 }


accessGroupN1 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 1."
	::=	{ accessGroupEntry 6 }

accessGroupN2 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 2."
	::=	{ accessGroupEntry 7 }

accessGroupN3 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 3."
	::=	{ accessGroupEntry 8 }

accessGroupN4 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 4."
	::=	{ accessGroupEntry 9 }

accessGroupN5 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 5."
	::=	{ accessGroupEntry 10 }

accessGroupN6 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 6."
	::=	{ accessGroupEntry 11 }

accessGroupN7 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 7."
	::=	{ accessGroupEntry 12 }

accessGroupN8 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 8."
	::=	{ accessGroupEntry 13 }

accessGroupN9 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 9."
	::=	{ accessGroupEntry 14 }

accessGroupN10 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 10."
	::=	{ accessGroupEntry 15 }

accessGroupN11 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 11."
	::=	{ accessGroupEntry 16 }

accessGroupN12 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 12."
	::=	{ accessGroupEntry 17 }

accessGroupN13 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 13."
	::=	{ accessGroupEntry 18 }

accessGroupN14 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 14."
	::=	{ accessGroupEntry 19 }

accessGroupN15 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 15."
	::=	{ accessGroupEntry 20 }

accessGroupN16 OBJECT-TYPE
	SYNTAX	INTEGER {
		inGroup(1),
		notInGroup(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Dictates if this MAC address shall belong to Named
		Access Group 16."
	::=	{ accessGroupEntry 21 }

accessGroupMembers OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"This is a bitmap, giving membership of the sixteen named access
		groups in a single integer.  Bit 0 corresponds to group N1, and
		bit 15 to group N16.

		Management stations which can make use of integer bitmaps should
		obviously use this variable, as it is more compact in PDU
		bandwidth, and is considerably faster for the agent to generate."
	::=	{ accessGroupEntry 22 }

accessGroupNamedIdMaxEntries OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The number Named Access Groups. In the RBLC this
		object has the value 16."
	::=	{ accessGroupDbase 4 }

accessGroupNamedIdTable OBJECT-TYPE
	SYNTAX	SEQUENCE OF AccessGroupNamedIdEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"A list of Named Access Group identifiers. The number
		is given by accessGroupNamedIdMaxEntries."
	::=	{ accessGroupDbase 5 }

accessGroupNamedIdEntry OBJECT-TYPE
	SYNTAX	AccessGroupNamedIdEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		""
	INDEX	{ accessGroupNamedIdIndex }
	::=	{ accessGroupNamedIdTable 1 }

AccessGroupNamedIdEntry ::= SEQUENCE {
	accessGroupNamedIdIndex
		INTEGER,
	accessGroupNamedIdIdentifier
		OCTET STRING (SIZE(20))
}


accessGroupNamedIdIndex OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"A unique value for each Named Access Group. Its value
		ranges between 1 and the value of
		accessGroupNamedNumber."
	::=	{ accessGroupNamedIdEntry 1 }

accessGroupNamedIdIdentifier OBJECT-TYPE
	SYNTAX	OCTET STRING
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"A textual identifier for this Named Access Group."

	::=	{ accessGroupNamedIdEntry 2 }

-- Protocol filter.

pcolOperation OBJECT-TYPE
	SYNTAX	INTEGER {
		and(1),
		or(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The logical operation of the individual protocol
		filters."
	::=	{ pcolFltr 1 }

pcolNumber OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The number of individual protocol filters. For the
		RBLC this value will be 8."
	::=	{ pcolFltr 2 }

pcolTable OBJECT-TYPE
	SYNTAX	SEQUENCE OF PcolEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"A list of protocol filter entries. The number is given
		by pcolNumber. This size is fixed. No gaps are allowed
		in the table."
	::=	{ pcolFltr 3 }

pcolEntry OBJECT-TYPE
	SYNTAX	PcolEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"A protocol filter entry."
	INDEX	{ pcolIndex }
	::=	{ pcolTable 1 }

PcolEntry ::= SEQUENCE {
	pcolIndex
		INTEGER,
	pcolInUse
		INTEGER,
	pcolState
		INTEGER,
	pcolIdentifier
		OCTET STRING (SIZE(16)),
	pcolOffset
		INTEGER,
	pcolMask
		OCTET STRING (SIZE(8)),
	pcolMatch
		OCTET STRING (SIZE(8)),
	pcolDecision
		INTEGER,
	pcolAction
		INTEGER
}


pcolIndex OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"A unique value for each protocol filter. Its value
		ranges between 1 and the value of pcolNumber."
	::=	{ pcolEntry 1 }

pcolInUse OBJECT-TYPE
	SYNTAX	INTEGER {
		notinuse(1),
		inuse(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"This object controls the appearance of valid protocol filter
		table entries, i.e. entries which contain a meaningful filter.
		Setting this field to 'notinuse' causes the row to be
		deleted"
	::=	{ pcolEntry 2 }

pcolState OBJECT-TYPE
	SYNTAX	INTEGER {
		off(1),
		on(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"This object is ON if the protocol filter in this entry
		is being used to filter frames. This object is only
		meaningful if pcolInUse is set to 'inuse'. This
		protocol filter is turned off by setting this object
		to OFF."
	::=	{ pcolEntry 3 }

pcolIdentifier OBJECT-TYPE
	SYNTAX	OCTET STRING
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"A string used to identify this protocol filter."
	::=	{ pcolEntry 4 }

pcolOffset OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Offset within the frame of the 4-byte field on which
		filtering is to be performed."
	::=	{ pcolEntry 5 }

pcolMask OBJECT-TYPE
	SYNTAX	OCTET STRING
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"This object is ANDed with the 4-byte field in the
		frame. The result is compared with pcolMatch."
	::=	{ pcolEntry 6 }

pcolMatch OBJECT-TYPE
	SYNTAX	OCTET STRING
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"This object is compared with the result of ANDing
		pcolMask with the 4-byte field."
	::=	{ pcolEntry 7 }

pcolDecision OBJECT-TYPE
	SYNTAX	INTEGER {
		nomatch(1),
		match(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Determines whether the comparison of pcolMatch and
		the masked data field will cause the action specified
		in pcolAction to be taken on a match, or not."
	::=	{ pcolEntry 8 }

pcolAction OBJECT-TYPE
	SYNTAX	INTEGER {
		filter(1),
		lopriority(2),
		hipriority(3)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The action specified for this individual protocol
		filter."

	::=	{ pcolEntry 9 }
-- The bridgeData Group

bridgeMgmt	OBJECT IDENTIFIER ::=	{ bridgeData 1 }

filterDataBase	OBJECT IDENTIFIER ::=	{ bridgeData 2 }

bridgeRestart	OBJECT IDENTIFIER ::=	{ bridgeData 3 }



-- The proprietory bridge management group.
--
-- It is initially being placed in the general bridge part of the Spider
-- MIB, although this may eventually have to change due to the bridge
-- specific nature of the management variables ie L480 are different
-- from R285/185s.


brgMgmtMyName OBJECT-TYPE
	SYNTAX	DisplayString
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The name associated with this bridge for the
		purpose of remote management. It is this name
		which shall be used within multicast name PDU's"
	::=	{ bridgeMgmt 1 }

brgMgmtHelloTime OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The time interval, in seconds, between the
		transmission of successive bridge management
		hello packets"
	::=	{ bridgeMgmt 2 }

brgMgmtManagerAddr OBJECT-TYPE
	SYNTAX	IpAddress
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The IP Address of the remote station currently
		managing the bridge. This remote station can
		be another bridge, or any device supporting
		Telnet. Note, that this address is not the
		same as that of a possible SNMP client which
		is managing the bridge."
	::=	{ bridgeMgmt 3 }

brgMgmtTableMaxEntries OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The maximum size of the Bridge Name Table."
	::=	{ bridgeMgmt 4 }

brgMgmtTableCurEntries OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The current number of known remote bridges in the
		Bridge Name Table."
	::=	{ bridgeMgmt 5 }

brgMgmtTable OBJECT-TYPE
	SYNTAX	SEQUENCE OF BrgMgmtEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"The table of known remote bridges which can be
		managed by this bridge."
	::=	{ bridgeMgmt 6 }

brgMgmtEntry OBJECT-TYPE
	SYNTAX	BrgMgmtEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"An entry in the Remote Bridge Table."
	INDEX	{ brgMgmtAddr }
	::=	{ brgMgmtTable 1 }

BrgMgmtEntry ::= SEQUENCE {
	brgMgmtAddr
		IpAddress,
	brgMgmtName
		OCTET STRING
}


brgMgmtAddr OBJECT-TYPE
	SYNTAX	IpAddress
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The IP address of a remote bridge"
	::=	{ brgMgmtEntry 1 }

brgMgmtName OBJECT-TYPE
	SYNTAX	OCTET STRING
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The name of the bridge to use when trying
		to remotely administer it."
	::=	{ brgMgmtEntry 2 }



-- The filter database group used by SpiderBridges

dynDBase	OBJECT IDENTIFIER ::=	{ filterDataBase 1 }

dynType OBJECT-TYPE
	SYNTAX	INTEGER {
		hardware(1),
		software(2)
	}
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"This object specifies how the dynamic filtering is
		implemented."
	::=	{ dynDBase 1 }

dynTableMaxEntries OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The maximum number of entries in the dynamic filter
		table."
	::=	{ dynDBase 2 }

dynTableCurEntries OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The current number of entries in the dynamic filter
		table."
	::=	{ dynDBase 3 }

dynTable OBJECT-TYPE
	SYNTAX	SEQUENCE OF DynEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"The dynamic filter table"
	::=	{ dynDBase 4 }

dynEntry OBJECT-TYPE
	SYNTAX	DynEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"A dynamic table entry."
	INDEX	{ dynAddr }
	::=	{ dynTable 1 }

DynEntry ::= SEQUENCE {
	dynAddr
		OCTET STRING (SIZE(6)),
	dynHomePort
		INTEGER,
	dynInUse
		INTEGER
}


dynAddr OBJECT-TYPE
	SYNTAX	OCTET STRING
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The dynamically learned MAC source address."
	::=	{ dynEntry 1 }

dynHomePort OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The port number, sptreePortIndex, on which the
		dynamic source address was received."
	::=	{ dynEntry 2 }

dynInUse OBJECT-TYPE
	SYNTAX	INTEGER {
		notinuse(1),
		inuse(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"This object is INUSE for valid dynamic table entries.
		Entries may be removed by setting it to NOTINUSE."
	::=	{ dynEntry 3 }

typeFltr	OBJECT IDENTIFIER ::=	{ filterDataBase 5 }

typeFltrStt OBJECT-TYPE
	SYNTAX	INTEGER {
		disabled(1),
		only(2),
		except(3)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"State of type filtering."
	::=	{ typeFltr 1 }

typeFltrMaxEntries OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The maximum number of entries allowed in the static
		type filter table."
	::=	{ typeFltr 2 }

typeFltrCurEntries OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The current number of entries in the static type
		filter table."
	::=	{ typeFltr 3 }

typeFltrTable OBJECT-TYPE
	SYNTAX	SEQUENCE OF TypeFltrEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"Static type filter table."
	::=	{ typeFltr 4 }

typeFltrEntry OBJECT-TYPE
	SYNTAX	TypeFltrEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"An entry in the static type filter table."
	INDEX	{ typeFltrFrom }
	::=	{ typeFltrTable 1 }

TypeFltrEntry ::= SEQUENCE {
	typeFltrFrom
		INTEGER,
	typeFltrTo
		INTEGER,
	typeFltrInUse
		INTEGER
}


typeFltrFrom OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Type filter table 'from' type (inclusive)."
	::=	{ typeFltrEntry 1 }

typeFltrTo OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Type filter table 'to' type (inclusive)."
	::=	{ typeFltrEntry 2 }

typeFltrInUse OBJECT-TYPE
	SYNTAX	INTEGER {
		notinuse(1),
		inuse(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Entries are removed by setting this object to
		NOTINUSE."

	::=	{ typeFltrEntry 3 }


-- The bridge management rstart group. Will eventually be replaced
-- by a more general group in SpiderMIB-II, but is required due to
-- the inappropriate tserverData group.


bridgeBootCount OBJECT-TYPE
	SYNTAX	Counter
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The number of times this system has been auto-booted.
		(This refers to auto-reboots only.)"
	::=	{ bridgeRestart 1 }

bridgeRestartCause1 OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"A code for a system error that causes a self-initiated
		restart. These codes are ordered from the earliest to
		the latest ie bridgeRestartCause1 is the earliest, and
		bridgeRestartCause4 is the latest. The code is
		expressed as an 8 digit hex number."
	::=	{ bridgeRestart 2 }

bridgeRestartCause2 OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"A code for a system error that causes a self-initiated
		restart. These codes are ordered from the earliest to
		the latest ie bridgeRestartCause1 is the earliest, and
		bridgeRestartCause4 is the latest. The code is
		expressed as an 8 digit hex number."
	::=	{ bridgeRestart 3 }

bridgeRestartCause3 OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"A code for a system error that causes a self-initiated
		restart. These codes are ordered from the earliest to
		the latest ie bridgeRestartCause1 is the earliest, and
		bridgeRestartCause4 is the latest. The code is
		expressed as a 8 digit hex number."
	::=	{ bridgeRestart 4 }

bridgeRestartCause4 OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"A code for a system error that causes a self-initiated
		restart. These codes are ordered from the earliest to
		the latest ie bridgeRestartCause1 is the earliest, and
		bridgeRestartCause4 is the latest. The code is
		expressed as a 8 digit hex number."
	::=	{ bridgeRestart 5 }

--
-- The index Group
--

supportedMaxEntries OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"Number of entries in the supported table."
	::=	{ spIndex 1 }

supportedTable OBJECT-TYPE
	SYNTAX	SEQUENCE OF SupportedEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"A table of OBJECT IDENTIFIERs, pointing to MIB groups
		which are supported in this agent."
	::=	{ spIndex 2 }

supportedEntry OBJECT-TYPE
	SYNTAX	SupportedEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"The OBJECT IDENTIFIER for a portion of the MIB,
		showing which parts of the MIB are implemented by the
		product."
	INDEX	{ supportedIndex }
	::=	{ supportedTable 1 }

SupportedEntry ::= SEQUENCE {
	supportedIndex
		INTEGER,
	supportedID
		OBJECT IDENTIFIER
}


supportedIndex OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"A simple numeric index into the supported table, to
		assist with indexing."
	::=	{ supportedEntry 1 }

supportedID OBJECT-TYPE
	SYNTAX	OBJECT IDENTIFIER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"A pointer to a supported MIB sub-tree"
	::=	{ supportedEntry 2 }

unSupportedMaxEntries OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"Number of entries in the unsupported table."
	::=	{ spIndex 3 }

unSupportedTable OBJECT-TYPE
	SYNTAX	SEQUENCE OF UnSupportedEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"A table of OBJECT IDENTIFIERs, pointing to MIB
		groups, tables OR variables which are NOT supported
		in this agent. The unsupported OBJECT IDENTIFIERs
		are always subtrees of the supported table (that is,
		they show the management station what elements of the
		supported groups are not implemented)."
	::=	{ spIndex 4 }

unSupportedEntry OBJECT-TYPE
	SYNTAX	UnSupportedEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"The OBJECT IDENTIFIER for a portion of the MIB,
		showing which parts of the supported MIB are not
		implemented by the product."
	INDEX	{ unSupportedIndex }
	::=	{ unSupportedTable 1 }

UnSupportedEntry ::= SEQUENCE {
	unSupportedIndex
		INTEGER,
	unSupportedID
		OBJECT IDENTIFIER
}


unSupportedIndex OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"A simple numeric index into the unsupported table, to
		assist with indexing."
	::=	{ unSupportedEntry 1 }

unSupportedID OBJECT-TYPE
	SYNTAX	OBJECT IDENTIFIER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"A pointer to an unsupported sub-tree of a supported
		MIB sub-tree"

	::=	{ unSupportedEntry 2 }


-- The spGeneral Group
--
--   This group contains those variables and tables which are present
--(or at least recommended) in all Spider products.  Of course, any
--   product which temporarily does not support an entry in this group
--   will indicate this in the 'unSupported' table.
--

mibVersion OBJECT-TYPE
	SYNTAX	DisplayString
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"This is an object which is unique to a particular MIB in
		a particular product. It is read by the SpiderManager
		and is broken down into the following structure:
		'<product version>:<MIB version>', where 'product
		version' is a string of the type '2.3.1'
		(product-specific), and 'MIB version' identifies
		the particular flavour of SpiderMIB, such as '1:0'"
	::=	{ spGeneral 1 }

admin		OBJECT IDENTIFIER ::=	{ spGeneral 2 }

admSessionStt OBJECT-TYPE
	SYNTAX	INTEGER {
		noManagementSession(1),
		localManagementSession(2),
		telnetManagementSession(3),
		snmpManagementSession(4),
		remoteBridgeManagementSession(5),
		latManagementSession(6),
		tp4ManagementSession(7),
		vtpManagementSession(8)
	}
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The state of the management session on the product. Management
		sessions can only be invoked if the value of this object is
		noManagementSession(1). Traps may be generated when this
		object changes (implementation specific)."
	::=	{ admin 1 }

admManagerAddr OBJECT-TYPE
	SYNTAX	IpAddress
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The IP address of the product initiating an SNMP or
		Telnet management session. This object is 0.0.0.0
		when no management session is underway, and is set to
		this value automatically when a session closes, or is
		timed out."
	::=	{ admin 2 }

admLockDevice OBJECT-TYPE
	SYNTAX	INTEGER {
		yes(1),
		no(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The host sets this variable to prevent other hosts from
		being able to use SNMP SET requests. This is intended for
		use when a host needs to carry out a series of SET
		operations as effectively one atomic access.  When this
		variable is set, the IP address of the host is copied into
		'admManagerAddr', and the management session timer is
		started. If the session timer expires without any contact
		by the locking host, the session lock is cleared, and the
		IP address zeroed. The standard Spider session time limit
		is two minutes."
	::=	{ admin 3 }

admOverrideDevice OBJECT-TYPE
	SYNTAX	INTEGER {
		yes(1),
		no(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The host sets this variable to override the current
		lock owner. This has the effect of zeroing the
		'admLockDevice' and 'admManagerAddr' variables,
		and cancelling the management session. A
		'sessionAborted' trap is sent to the host which
		locked the previous management session."
	::=	{ admin 4 }

admPrompt OBJECT-TYPE
	SYNTAX	DisplayString
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The string used for the command line prompt in a local
		or remote administration session."
	::=	{ admin 5 }

admPassword OBJECT-TYPE
	SYNTAX	DisplayString
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The password required to start a management session
		to the administration mode of the product. It is
		intended that this be encrypted by a simple algorithm
		before it is sent onto the network."
	::=	{ admin 6 }

admSignOnMsg OBJECT-TYPE
	SYNTAX	DisplayString
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The sign on message presented at the start of a local
		or remote administration session. This is typically
		the product type, name and version."
	::=	{ admin 7 }

admMgmtSessionTime OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The timeout used for management session closure. If a
		management session is idle for this time it will close
		automatically and no configuration change will be
		made. The unit is seconds."
	::=	{ admin 8 }

admLastWriteAddr OBJECT-TYPE
	SYNTAX	IpAddress
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The IP address of the source of the last received SNMP
		SET request."
	::=	{ admin 9 }

admRemManagerAddr OBJECT-TYPE
	SYNTAX	OCTET STRING (SIZE (0..64))
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The address of the product initiating a management session
		corresponding to admSessionStt. This object is of zero
		length when no management session is underway, and is
		set to this value automatically when a session closes,
		or is timed out."
	::=	{ admin 10 }

resources	OBJECT IDENTIFIER ::=	{ spGeneral 4 }

resSmartGatewayAddr OBJECT-TYPE
	SYNTAX	IpAddress
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The IP address of the default gateway for the product.
		A value of 0.0.0.0 is used if there is no default
		gateway."
	::=	{ resources 3 }

restart		OBJECT IDENTIFIER ::=	{ spGeneral 5 }

rstDoBoot OBJECT-TYPE
	SYNTAX	INTEGER {
		doBoot(1),
		noMeaning(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"When set to doBoot(1) the product should send the
		getResponse message using the parameters rstBootFrom and
		rstBootfilename(if applicable), and then reboot.  Reading
		this object always returns a value of noMeaning(2)."
	::=	{ restart 1 }

rstDoRestart OBJECT-TYPE
	SYNTAX	INTEGER {
		doRestart(1),
		noMeaning(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"When set to doRestart(1) the product should restart after
		sending the getResponse message.  Reading this object
		always returns a value of noMeaning(2)."
	::=	{ restart 4 }

rstNeedRestart OBJECT-TYPE
	SYNTAX	INTEGER {
		dontNeedRestart(1),
		needRestart(2)
	}
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"If the value of this object is needRestart(2) some
		configuration parameters have been changed which will not
		take effect until the product is restarted using
		rstDoRestart."
	::=	{ restart 5 }

rstDownLoadStt OBJECT-TYPE
	SYNTAX	INTEGER {
		notDownLoading(1),
		downLoading(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"If the value of this object is downLoading(2) a
		configuration download is in progress. The following rules
		apply: If a management session closes normally and
		rstDownLoadStt has the value downLoading(2) non-volatile
		storage is updated and the product restarts. If a
		management session closes for any other reason and
		rstDownLoadStt has the value downLoading(2) non-volatile
		storage is NOT updated and the product restarts. This
		ensures the original configuration is restored leaving the
		product in a consistent state."
	::=	{ restart 6 }

rstNumberRestarts OBJECT-TYPE
	SYNTAX	Counter
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"A count of the number of restarts (this includes
		reboots) the product has undergone."
	::=	{ restart 7 }

rstLastConfigChngTime OBJECT-TYPE
	SYNTAX	TimeTicks
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The time at which the configuration of the agent was
		last changed. A configuration change is considered
		to have been made when non-volatile memory is updated
		and the value of this object is the value of sysUpTime
		when this occurs. Note that a configuration change
		can be made using any access method such as SNMP, a
		local terminal or a TELNET connection."
	::=	{ restart 8 }

-- The trap count group/table
--
-- The table holds a send count of each of the types of trap supported
-- by the device, and an enable column to let users turn off transmission
-- of specific traps

trapCount	OBJECT IDENTIFIER ::=	{ spSnmp 1 }

trapCountClear OBJECT-TYPE
	SYNTAX	INTEGER {
		clearCounts(1),
		noMeaning(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"When set to clearCounts(1) the count of all traps in
		the trapCountTable is reset to zero. Reading this
		object always returns a value of noMeaning(2)."
	::=	{ trapCount 1 }

trapCountMaxEntries OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The maximum number of entries allowed in the trapCountTable.
		The actual number is the total of all of the types of
		generic and enterprise traps that the device can send."
	::=	{ trapCount 2 }

trapCountTable OBJECT-TYPE
	SYNTAX	SEQUENCE OF TrapCountEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"A list of the numbers of traps of each type sent."
	::=	{ trapCount 3 }

trapCountEntry OBJECT-TYPE
	SYNTAX	TrapCountEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"An entry of trap counts for a particular trap type."
	INDEX	{ trapCountIndex }
	::=	{ trapCountTable 1 }

TrapCountEntry ::= SEQUENCE {
	trapCountIndex
		INTEGER,
	trapCountType
		INTEGER,
	trapCountCode
		INTEGER,
	trapCountEnable
		INTEGER,
	trapCountCount
		Counter,
	trapCountTime
		TimeTicks,
	trapCountDescr
		DisplayString
}


trapCountIndex OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"A numeric index used to index the trapCountTable. Its
		value ranges between 1 and the value of
		trapCountMaxEntries."
	::=	{ trapCountEntry 1 }

trapCountType OBJECT-TYPE
	SYNTAX	INTEGER {
		generic(1),
		enterprise(2)
	}
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The type of trap, generic or enterprise."
	::=	{ trapCountEntry 2 }

trapCountCode OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The enumerated code for the trap, generic as
		specified in [3] or enterprise as specified in the
		management information document associated with
		the product."
	::=	{ trapCountEntry 3 }

trapCountEnable OBJECT-TYPE
	SYNTAX	INTEGER {
		enableTrap(1),
		disableTrap(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"When the value is enableTrap(1) traps of this type are
		forwarded to all stations in the trapDestsTable,
		counted in the trapCountTable and stored in the
		allTrapTable(if this is supported by the product).
		When the value is disableTrap(2) traps of this type
		are not forwarded to all stations in the
		trapDestsTable. They are however counted in the
		trapCountTable and entered in the allTrapTable (if
		this is supported by the product)."
	::=	{ trapCountEntry 4 }

trapCountCount OBJECT-TYPE
	SYNTAX	Counter
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"A count of the number of traps sent of each type since
		the last reset of the product."
	::=	{ trapCountEntry 5 }

trapCountTime OBJECT-TYPE
	SYNTAX	TimeTicks
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The time of the last occurrence of a particular trap
		type since the last reset of the product in one
		hundredths of a second."
	::=	{ trapCountEntry 6 }

trapCountDescr OBJECT-TYPE
	SYNTAX	DisplayString
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"A description of the type of enterprise trap being
		transmitted."
	::=	{ trapCountEntry 7 }

trapDests	OBJECT IDENTIFIER ::=	{ spSnmp 3 }

trapDestsCheckAddr OBJECT-TYPE
	SYNTAX	INTEGER {
		validateAddresses(1),
		dontValidateAddresses(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The trapDestsCheckAddr object selects whether the
		IP address of a station requesting a management
		session is validated for presence in the trapDests
		table. If validation is enabled and the address in the
		SNMP request is not present in the trapDests table the
		request is rejected. A trap may be sent if this occurs,
		the choice is product specific."
	::=	{ trapDests 1 }

trapDestsMaxEntries OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The maximum number of entries in the trapDestsTable."
	::=	{ trapDests 2 }

trapDestsCurEntries OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The number of traps in the trapDestsTable at any
		instant."
	::=	{ trapDests 3 }

trapDestsTable OBJECT-TYPE
	SYNTAX	SEQUENCE OF TrapDestsEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"A list of the destinations to which traps are sent."
	::=	{ trapDests 4 }

trapDestsEntry OBJECT-TYPE
	SYNTAX	TrapDestsEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"An entry for a station address to which traps are sent"
	INDEX	{ trapDestsIpAddr }
	::=	{ trapDestsTable 1 }

TrapDestsEntry ::= SEQUENCE {
	trapDestsIpAddr
		IpAddress,
	trapDestsSerialAddr
		IpAddress,
	trapDestsPhoneNumber
		OCTET STRING,
	trapDestsSendTo
		INTEGER,
	trapDestsEnable
		INTEGER,
	trapDestsCommunityName
		OCTET STRING,
	trapDestsInUse
		INTEGER
}


trapDestsIpAddr OBJECT-TYPE
	SYNTAX	IpAddress
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The IP address of a station to which traps are sent."
	::=	{ trapDestsEntry 1 }

trapDestsSerialAddr OBJECT-TYPE
	SYNTAX	IpAddress
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The serial IP address of a station to which traps are
		sent."
	::=	{ trapDestsEntry 2 }

trapDestsPhoneNumber OBJECT-TYPE
	SYNTAX	OCTET STRING
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The telephone number of a modem connected to the
		product which can be dialed up to send traps."
	::=	{ trapDestsEntry 3 }

trapDestsSendTo OBJECT-TYPE
	SYNTAX	INTEGER {
		primaryMedium(1),
		serialLine(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The interface to send traps to. This selects whether
		to send traps via the primary medium or the serial
		line."
	::=	{ trapDestsEntry 4 }

trapDestsEnable OBJECT-TYPE
	SYNTAX	INTEGER {
		sendTraps(1),
		dontSendTraps(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"When the value is sendTraps(1) traps are sent to this
		address and are counted in the trapCountTable and
		entered in the allTrapTable. When the value is
		dontSendTraps(2) traps are not sent to this address.
		They are however counted in the trapCountTable and
		are entered in the allTrapTable."
	::=	{ trapDestsEntry 5 }

trapDestsCommunityName OBJECT-TYPE
	SYNTAX	OCTET STRING
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The community name to use when sending traps to this
		address."
	::=	{ trapDestsEntry 6 }

trapDestsInUse OBJECT-TYPE
	SYNTAX	INTEGER {
		notInUse(1),
		inUse(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Whether this entry is in use or not. This field is used
		to delete entries from this table."
	::=	{ trapDestsEntry 7 }

-- The spantree group used by Spider products

spantree	OBJECT IDENTIFIER ::=	{ spProtocols 14 }

sptreeGroupAddr OBJECT-TYPE
	SYNTAX	OCTET STRING
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The multicast address used by BPDUs."
	::=	{ spantree 15 }

sptreeStt OBJECT-TYPE
	SYNTAX	INTEGER {
		disabled(1),
		enabled(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The Spanning Tree State of the bridge."
	::=	{ spantree 16 }

sptreeInit OBJECT-TYPE
	SYNTAX	INTEGER {
		noinitialise(1),
		initialise(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"When set to INITIALISE the parameters and timers of
		the Spanning Tree algorithm and protocol are
		initialised."
	::=	{ spantree 17 }


-- This document describes the sip MIB, which is a part of the SpiderMIB.
-- It contains those objects, which are associated with IP, but are also
-- configurable by the user from the ADMIN interface.  There are
-- effectively two copies of the folowing variables: one in the
-- EEROM, and another dynamic copy in the kernel. The kernel copies
-- aren't generally updated until the system is restarted.

spIp		OBJECT IDENTIFIER ::=	{ spProtocols 16 }

sipNxtBootTableMaxEntries OBJECT-TYPE
	SYNTAX	INTEGER
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"The maximum number of entries allowed in the
		NxtBootTable."
	::=	{ spIp 1 }

sipNxtBootTable OBJECT-TYPE
	SYNTAX	SEQUENCE OF SipNxtBootEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"A table of IP interfaces, used to change the IP
		address, subnet mask and broadcast address, the next
		time the system is booted. The table indexed by the
		current IP address of the interface."
	::=	{ spIp 2 }

sipNxtBootEntry OBJECT-TYPE
	SYNTAX	SipNxtBootEntry
	ACCESS	not-accessible
	STATUS	mandatory
	DESCRIPTION
		"This table entry consists of the current IP address of
		this interface, followed by the new IP address,
		broadcast form and subnet masks. These will not take
		effect, until the system is rebooted."
	INDEX	{ sipNxtBootCurIp }
	::=	{ sipNxtBootTable 1 }

SipNxtBootEntry ::= SEQUENCE {
	sipNxtBootCurIp
		IpAddress,
	sipNxtBootNxtIp
		IpAddress,
	sipNxtBootBbdCast
		INTEGER,
	sipNxtBootSubnetMask
		IpAddress
}


sipNxtBootCurIp OBJECT-TYPE
	SYNTAX	IpAddress
	ACCESS	read-only
	STATUS	mandatory
	DESCRIPTION
		"This is the current IP address of the interface."
	::=	{ sipNxtBootEntry 1 }

sipNxtBootNxtIp OBJECT-TYPE
	SYNTAX	IpAddress
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The desired IP address of this interface, once the
		system is rebooted. The subnetmask will be changed
		accordingly, to cover the default mask for that IP
		address."
	::=	{ sipNxtBootEntry 2 }

sipNxtBootBbdCast OBJECT-TYPE
	SYNTAX	INTEGER {
		allones(1),
		allzeroes(2)
	}
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"Sets the broadcast address to be all ones, or all
		zeroes."
	::=	{ sipNxtBootEntry 3 }

sipNxtBootSubnetMask OBJECT-TYPE
	SYNTAX	IpAddress
	ACCESS	read-write
	STATUS	mandatory
	DESCRIPTION
		"The subnet mask associated with the IP address entry.
		If sipNxtBootNxtIp is specified, then the subnet
		mask automatically changes to the default mask for
		the network class of the new IP entry. If
		sipNxtBootSubnetMask is also changed, it must at
		least cover the default for the new IP address (also
		dependent upon its network class), or the current IP
		address if no new one specified. Also, if the new
		address is on a different network, and there are
		gateways on the current network, a badValue error
		will be returned."

	::=	{ sipNxtBootEntry 4 }


END


